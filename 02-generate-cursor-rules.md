/Generate Cursor Rules

Cursor Rules это постоянный, управляемый контекст курсора, который содержит в себе правила поведения IDE, они лежат в директории .cursor/rules/, которая коммитается в репозиторий, что позволяет версионировать правила курсора вместе с кодом проекта.

Обычно указанная папка находится в корне проекта, но случае если проект имеет формат монорепозитория возможно для каждого подпроекта сделать свой собственный набор правил.

```
project/
  .cursor/rules/    # глобальные правила
  backend/
    .cursor/rules/  # правила бэкенда
  frontend/
    .cursor/rules/  # правила фронтенда
```

Внутри указанных директорий в .mdc-файлах хранятся собственно сами правила, MDC (https://github.com/nuxt-content/mdc) как я понял был выбран потому, что помимо текста в Markdown там можно хранить дополнительные метаданные.

Пример .mdc-файла:

```markdown
---
description: Краткое описание данного набора правил
globs: app/**/*.php
alwaysApply: true
---

- Следуй паттерну PSR-2
- Используй camelCase в названии фукций

@ссылка-на-файл.php
@или-скажем-на-ТЗ.md#главу-1
@или-на-другой.mdc
```

Тексты из .mdс-файлов подмешиваются в контекст через `alwaysApply` (true - всегда), если не указывать `alwaysApply` то агент будет сам решать когда их применять, а ещё можно заставить агента выполнить их принудительно (ручной вызов через `@название-mdc-файла`).


# Общее описание правил
Изучи техническое задание или спецификации, вытащи понятия и терминологию, ограничения, нефункциональные требования, список вопросов.

# Реализация "класс-за-раз" слоями
Если потребуется сгенерировать несколько классов кода выполняй это последовательно, слоями:
- Слой 1 - классы без зависимостей.
- Слой 2 - классы, зависящие только от слоя 1 (и от себя).
- Слой 3 - классы, зависящие от слоёв 1–2 (и от себя), и т.д.
На каждый класс пусть агент делает минималистичные unit-тесты.

# Процесс выполнения задачи (каждый раз)
1) Сначала кратко перечисли: "Что я поняла" + "Что сделаю сейчас";
2) Напиши тесты, выполни их и убедись, что новая логика ещё не работает;
3) Реализуй ровно один запрошенный класс/модуль/метод/функцию (если пользователь не просил иного);
4) Выполни ранее написанные тесты, после чего все тесты системы;
5) В конце дай короткий чек-лист: что готово, что предлагаешь делать дальше (1–3 пункта).

# Минимизируй болтовню
Пиши только по делу: шаги, файлы, код, тесты.
Задавай вопросы - только блокером, если требуется уточнения надо явно попросить пользователя и без этого уточнения нельзя продолжить.

# Правила оформления кода
- Следуй стилю и линтингу репозитория.
- Не усложняй, пиши минимальный код, который проходит тесты и соответствует ТЗ.
- Комментарии в коде - только на английском.
- Не сохраняй секреты/ключи в коде.
- Никаких эмодзи.

# Контекст
- Если есть Cursor Rules (.cursor/rules/*.mdc) - они приоритетнее общих правил.
- Считай, что истинные требования в правилах требований и связанных документах.
- Архитектурные границы и карты классов опиши в правилах архитектуры.
- Code Style опиши отдельным правилом и пусть оно действует глобально на все файлы с кодом.
- Процедуру тестирования опиши отдельным файлом, пусть там будет описана последовательность выполнения команд.

# Автоматизация
Когда пользователь говорит: "реализуй функцию/метод/класс такой-то по правилам проекта"
- Найди/уточни его место в архитектуре (простая привязка: слой, зависимости, публичный API);
- Реализуй минимальные тесты класса;
- Реализуй код класса;
- Выполни тесты класса;
- Не трогай другие классы, кроме зависимых интерфейсов/заглушек.
