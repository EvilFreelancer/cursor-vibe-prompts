# Cursor вайб-промты

Решил поделиться подборочкой некоторых моих промтов, которыми часто пользуюсь последние полгода-год, надеюсь они и вам пригодятся. 

## Инициализация

Обычно если мне нужно быстро разобраться в каком-то новом проекте написанном на python я первым делом прошу Cursor изучить проект тем самым прогреваю контекст:
```
Изучи код, документацию и тесты, `venv` в .venv, запускать тесты через `pytest`, выполни тесты, попытайся разобраться что и как работает, напиши краткий отчёт.
```

## Генерация правил

Если проект новый или старый и у него нет правил Cursor Rules то я прошу курсор сгенерировать правила работы с проектом (к сожалению авторы в 2.0 решили убрать эту фичу, но можно описать как генерировать правила самостоятельно).

Тут очень важно у вас в корне проекта были текстовые спецификации проекта подготовленные заранее, либо как вариант актуальная документация.

Желательно чтобы в спеках или доке была информация об архитектуре, о том какую бизнес-задачу решает система, от каких компонентов система зависит и каким образом предполагается пользователям с ней взаимодействовать. Нефункциональные требования тоже будут плюсом, это чуть уменьшит полёт фантазии модели.

```
/Generate Cursor Rules

Cursor Rules это постоянный, управляемый контекст курсора, который содержит в себе правила поведения IDE, они лежат в директории .cursor/rules/, которая коммитается в репозиторий, что позволяет версионировать правила курсора вместе с кодом проекта.

Обычно указанная папка находится в корне проекта, но случае если проект имеет формат монорепозитория возможно для каждого подпроекта сделать свой собственный набор правил.

\```
project/
  .cursor/rules/    # глобальные правила
  backend/
    .cursor/rules/  # правила бэкенда
  frontend/
    .cursor/rules/  # правила фронтенда
\```

Внутри указанных директорий в .mdc-файлах хранятся собственно сами правила, MDC (https://github.com/nuxt-content/mdc) как я понял был выбран потому, что помимо текста в Markdown там можно хранить дополнительные метаданные.

Пример .mdc-файла:

\```markdown
---
description: Краткое описание данного набора правил
globs: app/**/*.php
alwaysApply: true
---

- Следуй паттерну PSR-2
- Используй camelCase в названии фукций

@ссылка-на-файл.php
@или-скажем-на-ТЗ.md#главу-1
@или-на-другой.mdc
\```

Тексты из .mdс-файлов подмешиваются в контекст через `alwaysApply` (true - всегда), если не указывать `alwaysApply` то агент будет сам решать когда их применять, а ещё можно заставить агента выполнить их принудительно (ручной вызов через `@название-mdc-файла`).


# Общее описание правил
Изучи техническое задание или спецификации, вытащи понятия и терминологию, ограничения, нефункциональные требования, список вопросов.

# Реализация "класс-за-раз" слоями
Если потребуется сгенерировать несколько классов кода выполняй это последовательно, слоями:
- Слой 1 - классы без зависимостей.
- Слой 2 - классы, зависящие только от слоя 1 (и от себя).
- Слой 3 - классы, зависящие от слоёв 1–2 (и от себя), и т.д.
На каждый класс пусть агент делает минималистичные unit-тесты.

# Процесс выполнения задачи (каждый раз)
1) Сначала кратко перечисли: "Что я поняла" + "Что сделаю сейчас";
2) Напиши тесты, выполни их и убедись, что новая логика ещё не работает;
3) Реализуй ровно один запрошенный класс/модуль/метод/функцию (если пользователь не просил иного);
4) Выполни ранее написанные тесты, после чего все тесты системы;
5) В конце дай короткий чек-лист: что готово, что предлагаешь делать дальше (1–3 пункта).

# Минимизируй болтовню
Пиши только по делу: шаги, файлы, код, тесты.
Задавай вопросы - только блокером, если требуется уточнения надо явно попросить пользователя и без этого уточнения нельзя продолжить.

# Правила оформления кода
- Следуй стилю и линтингу репозитория.
- Не усложняй, пиши минимальный код, который проходит тесты и соответствует ТЗ.
- Комментарии в коде - только на английском.
- Не сохраняй секреты/ключи в коде.
- Никаких эмодзи.

# Контекст
- Если есть Cursor Rules (.cursor/rules/*.mdc) - они приоритетнее общих правил.
- Считай, что истинные требования в правилах требований и связанных документах.
- Архитектурные границы и карты классов опиши в правилах архитектуры.
- Code Style опиши отдельным правилом и пусть оно действует глобально на все файлы с кодом.
- Процедуру тестирования опиши отдельным файлом, пусть там будет описана последовательность выполнения команд.

# Автоматизация
Когда пользователь говорит: "реализуй функцию/метод/класс такой-то по правилам проекта"
- Найди/уточни его место в архитектуре (простая привязка: слой, зависимости, публичный API);
- Реализуй минимальные тесты класса;
- Реализуй код класса;
- Выполни тесты класса;
- Не трогай другие классы, кроме зависимых интерфейсов/заглушек.
```

## Исправление бага

В случае если нужно решить какой-то баг на прогретом контексте пишем текстом, что нужно исправить и далее такую вот простенькую инструкцию:
```
<описание бага>

Сначала напиши тест воспроизводящий данный баг, выполни его и убедись, что ошибка действительно есть, потом пиши код исправляющий ошибку и выполни тест, вноси исправления до тех пор, пока новые тест не заработает, выполни прогонку всех тестов и если они все зелёные пиши краткий отчёт о проделанной работе.
```

## Финальная прогонка

Перед тем как коммитать файлы в репозиторий я прошу курсор выполнить следующее:
```
Используя `pre-commit run -a` выполни проверку всех файлов, в случае возникновения ошибок внеси корректировки в соответствии с рекомендациями линтеров.
```
> Предполагается, что у меня уже настроен pre-commit, который тригерит хуки ruff, flake8, docformatter, mdformat и так далее.
